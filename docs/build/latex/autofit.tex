%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{autofit Documentation}
\date{Jun 03, 2019}
\release{1}
\author{Renzo Tiranti}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Aim and basic specifications of the Autofit system}
\label{\detokenize{intro:aim-and-basic-specifications-of-the-autofit-system}}\label{\detokenize{intro::doc}}\label{\detokenize{intro:welcome-to-autofit-documentation-s-documentation}}
By Autofit we mean an IT system, built around Python and a relation database aimed at the full automation
of calibration tasks for IPV purposes. Though at least initially focused on Equity, efforts will be spent to
maintain the implementation as general as possible.

The basic issues in implementing such system are:
\begin{enumerate}
\item {} 
IPV methodologies are interdependent and related through a hierachical dependency tree - for example, volatility calibration is performed only after the forward and implied volatility calculation

\item {} 
Different methodologies can be applied to the calibration of the same parameters depending on the available market data

\item {} 
New methodoogies can be inserted in the hierarchy tree with minimal changes to the code

\item {} 
The calibration tasks must be run in parallel and ideally on different machine

\item {} 
The system must cope with exeptions and failures of particular market data with no disruption on unrelated tasks

\item {} 
In case of catastrophic collapse, the system can be restarted from the last valid state

\end{enumerate}


\chapter{The MRP database, slots and producers}
\label{\detokenize{slot_prod::doc}}\label{\detokenize{slot_prod:the-mrp-database-slots-and-producers}}
The system is based on two abstractions of data and processing: \sphinxstyleemphasis{slots} and \sphinxstyleemphasis{producers}.
The slots are linked to entries in a database called MRP table, where the acronyms
stands for Market Data, Reports and Parameters.


\section{Slot}
\label{\detokenize{slot_prod:slot}}
The slot in an abstraction of a collection of homogeneous data, which is
indexed by a string \sphinxstyleemphasis{name} and whose data is indicated by a date and a
collection of supplementary keys.
It is called slot because once data is generated and wrapped in a slot, it is
inserted into the MRP table. Example of slot’s name may be
\sphinxstylestrong{MarketData.Vanilla.Totem} or \sphinxstylestrong{ImpliedVolatility.Vanilla.Totem} or
\sphinxstylestrong{ProductRate.TRS.Totem}.

\begin{sphinxadmonition}{note}{\label{slot_prod:index-0}Todo:}
It is unclear how the slot can be defined, i.e. it represents a
homogeneous dataset,
but how is the scope determined? For example, option prices
should be grouped into a unique slot based on
expiry/strike/underlying or just underlying? Probably the grouping
should be also determined by the primary keys, so the question is:
what are the primary keys for a slot?
\begin{quote}

This must be decided or it won’t be possible to handle proxy.
\end{quote}
\end{sphinxadmonition}

Slots are characterized by a \sphinxstylestrong{state}
\begin{enumerate}
\item {} \begin{description}
\item[{updated}] \leavevmode
The slot’s data was updated and processing has not started yet. We need This
state to \sphinxstylestrong{trigger} Producers, for example when the system is restarted

\end{description}

\item {} \begin{description}
\item[{pending}] \leavevmode
The slot’s data has just been generated and all linked producers are processing
the data

\end{description}

\item {} \begin{description}
\item[{current}] \leavevmode
The slot’s data has been processed by all the linked producers.

\end{description}

\item {} \begin{description}
\item[{invalid}] \leavevmode
Some non-recoverable error happened during the processing

\end{description}

\item {} \begin{description}
\item[{stale}] \leavevmode
At least one of the upstream slots changed status to Failed/Updated/Stale

\end{description}

\item {} \begin{description}
\item[{void}] \leavevmode
This is the starting state of a slot, when no data has been produced yet

\end{description}

\end{enumerate}

\begin{sphinxadmonition}{warning}{Warning:}
The slots’ state is a mess, we need clarity, and a clear definition
of what those states really mean!!!
\end{sphinxadmonition}

The chart below shows how the state evolves and what triggers changes in the
state

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.75]{{slot_states}.png}\hspace*{\fill}}


\subsection{Brainstorming}
\label{\detokenize{slot_prod:brainstorming}}
How do we handle proxies, or cases in which many input slots feed into
a fewer numbers of output slots?

To to this there must be a logic that performs aggregation of slots’ keys.

\begin{sphinxadmonition}{warning}{Warning:}
Some slots may need to be linked, for example product rate and
dividends are related.
\end{sphinxadmonition}


\subsection{The SID}
\label{\detokenize{slot_prod:the-sid}}
Each data in the slot is identified by a unique id the \sphinxstyleemphasis{SID}. This is not a
duplicate of the slot’s key as the date triggers a new SID.


\subsection{The Listeners}
\label{\detokenize{slot_prod:the-listeners}}
To each slot is associated a list of producers, or \sphinxstyleemphasis{listeners} in this context,
that has the slot as required or optional, see next section for the definition.
This list is required so that, upon generation of new or updated slots, the
depending producers are notified.


\subsection{A journey inside the slot life!}
\label{\detokenize{slot_prod:a-journey-inside-the-slot-life}}\begin{itemize}
\item {} 
A slot is produced and it goes into the table with ‘updated’ state.

\item {} 
All listeners are notified and acknowledge the slot was updated

\item {} 
The listeners also notify the slots they produce of the event, and those slots
become ‘stale’

\item {} 
The producers perform their job, return the results and notify the slot  of
their completion

\item {} 
The triggering slot compare the listed of producers which acknowledged the
change and the producers which returned the results

\item {} 
If all producers have performed the task, the slot’s status becomes ‘current’

\item {} 
Now one of the slots affering to this slot becomes ‘stale’. This slot becomes
stale too and notified to all producers

\end{itemize}


\section{Producer}
\label{\detokenize{slot_prod:producer}}
A producer is a process which, given a list of optional input slots, produces a
number of output slots. A producer will always have at least one slot as output.
A producer also must define a list of:
\begin{enumerate}
\item {} \begin{description}
\item[{Required input slots}] \leavevmode
These are the minimum data required by the producer to perform the task.
A required slot can be \sphinxstylestrong{inclusive} or \sphinxstylestrong{exclusive}, which means that the
slot must not be available to trigger to producer. A required slot can then
be \sphinxstylestrong{fault\_tolerant}, i.e. failed slots are still considered for joining
operation, otherwise a failed input slot make stale all produced slots.
This differentiation is needed to handle proxies.

\end{description}

\item {} \begin{description}
\item[{Filters}] \leavevmode
Filters are applied to the slots’ key to restrict the Producer activities
to a narrower set of slots.

\end{description}

\item {} \begin{description}
\item[{Provided slots}] \leavevmode
The outputs that the producer commits to provided. The producer assigns to
each output slot a priority. No other producer may not output the same slot
with equal priority.

\end{description}

\end{enumerate}

Furthermore, each running producer is identified by a unique id or \sphinxstylestrong{pid}

\begin{sphinxadmonition}{note}{Note:}
The “Optional Slots” have been \sphinxstylestrong{removed}. That behavior can be
simulating adding new producers having those optional slots as required.
\end{sphinxadmonition}


\subsection{Producer states}
\label{\detokenize{slot_prod:producer-states}}
The diagram below shows the state diagram for the producer:

\begin{sphinxadmonition}{note}{Note:}
The \sphinxstylestrong{scheduled} state was introduced to handle methodologies
based on aggregation of data (for example proxy). For those, it is
pointless kicking-off new producers as soon as new data is available.
Better to schedule, i.e. delay, the processing for a while as very
likely new data will become available in the meanwhile.
\end{sphinxadmonition}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.75]{{prod_states}.png}\hspace*{\fill}}


\subsection{Brainstorming}
\label{\detokenize{slot_prod:id1}}
The producer is a template for actual running methodologies. It establishes
relationship with data and how slots are aggregated. But running producers are
\sphinxstyleemphasis{instance} of the producer template.


\subsection{Producer types}
\label{\detokenize{slot_prod:producer-types}}
There are different type of producers:
\begin{itemize}
\item {} \begin{description}
\item[{Demoniac producers}] \leavevmode
This producer is constantly running in the background. Example of this type
of producers is the \sphinxstyleemphasis{Totem Producer}, which continuously polls for new data
from Totem

\end{description}

\item {} \begin{description}
\item[{Non-demoniac producers}] \leavevmode
They have limited life span and terminate once all output slots are produced

\end{description}

\end{itemize}


\subsection{Producer output}
\label{\detokenize{slot_prod:producer-output}}
Apart from the output slots, the data generated by the processing, the producer
must return the input slots’ used for the production of each output slot.
This is needed to build a dependency tree. Indeed, once the producer output is
processed and output slots’ stored in the MRP table, the dependency tree
SLOT\_TREE must be updated accordingly.


\subsection{Producer Proxy}
\label{\detokenize{slot_prod:producer-proxy}}
All producers are executed through a common interface called \sphinxstyleemphasis{Producer Proxy}.
Proxies are divided into
\begin{itemize}
\item {} \begin{description}
\item[{Multi-threaded (MT) Proxies}] \leavevmode
Producers are not executed in a different process. For example, producers
which simply aggregates or filters data can be run in a separated thread.
Note that producers accessing analytic funcionality (CAL, Zuul) may not be
multi-treaded producers

\end{description}

\item {} \begin{description}
\item[{Multi-processing (MP) Proxies}] \leavevmode
Producers are executed in their own process and potentially in a different
machines

\end{description}

\end{itemize}

The Proxy is responsible for join together all the slots needed for the producer to run.
A set on joined slots constitute an \sphinxstyleemphasis{parcel}.
An parcel is a collection of slots required to produce at least one output slot. For example, implied volatility and forward for asset A constitutes a parcel for the volatiity fitting producer

A further differentiation is in
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxstyleemphasis{Independent} Proxies}] \leavevmode
Producers are executed as soon as parcels are available, but subject to batch
sizes MIN\_BATCH.

\end{description}

\end{itemize}

\begin{sphinxadmonition}{note}{\label{slot_prod:index-1}Todo:}
Add example of Independent Proxies
\end{sphinxadmonition}
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxstyleemphasis{Dependent} Proxies}] \leavevmode
Producers are triggered once all the input slots’ producers are terminated.
This type of proxy is needed to execute methodologies based on the whole
aggregated data, for example calculation of VarSwap basis. For Dependent
Proxies MIN\_BATCH=9999

\end{description}

\end{itemize}

In order for Proxy to work, they must:
\begin{itemize}
\item {} 
Receive notification of changes in status of required and optional slots

\item {} 
Aggregate the slots into parcels.

\item {} 
Trigger the actual producer once a set of conditions are met

\end{itemize}

The conditions to be satisfied to trigger a calculation are:
\begin{itemize}
\item {} 
The number of available parcels are more than MIN\_BATCH \textgreater{} 0.

\item {} 
The number of available parcels is less than MIN\_BATCH but the parcels have been
available for more than MAX\_WAIT\_TIME.

\item {} 
The proxy is Dependent and all the input slots’ producers have terminated

\end{itemize}


\subsection{A journey inside the producer life!}
\label{\detokenize{slot_prod:a-journey-inside-the-producer-life}}
A slot is completed. It notifies this to the producer, which is one of the
listeners, by communicating the sid.
The producer acknowledges it (do we really need this? \sphinxstylestrong{Yes I do!} This is
required to sort out the issue with notifying producer with updated data) and
registers the
new available data. It then checks whether it has received the required number
of slots. If it does, then parcel is sent for processing. Now, it can happen
that one of the input slots becomes invalid, or than a new optional slot
becomes available. In this case the producer is inhibited. A signal is sent
to the running producer. Once the producer returns the output, either because
it stopped processing upon inhibition signal or because it terminated is job,
that output is simply neglected but the output slot must be set to \sphinxstylestrong{invalid.}
Why we need this? Not sure, let’s assume we need to flag the failure.


\subsection{Joining slots into parcels - proposal}
\label{\detokenize{slot_prod:joining-slots-into-parcels-proposal}}\begin{enumerate}
\item {} 
a slot is received and stored in the parcels\_table

\item {} 
consider all the producers affected

\item {} 
join the required slots together

\item {} 
\sphinxstylestrong{projects} the keys on the producer aggregation keys.
This is the key point: we know upfront which producers are affected

\item {} 
select all the slots with keys on each distinct projection

\item {} 
If a producer with that aggregation still running then inhibits it before
starting the new one

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
steps 2-6 must be in a separate function, which may be possible to
call for example by a scheduler.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
to joining at step 3 may not be required, but at the moment it
seems required to process batches of different slots, for example
for proxies calculation
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
A tricky aspect is that the calculation is triggered by an event!
So for example this makes difficult to restart from a crash.
This can be addressed leveraging on the slot \sphinxstylestrong{updated} status. So
slots which are \sphinxstylestrong{pending} can have their status overridden to
\sphinxstylestrong{updated}.
\end{sphinxadmonition}


\subsection{Examples}
\label{\detokenize{slot_prod:examples}}

\subsubsection{VarSwapVolBasis calculation}
\label{\detokenize{slot_prod:varswapvolbasis-calculation}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{required\PYGZus{}slots} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Totem}\PYG{o}{.}\PYG{n}{VarSwapVolBasis}\PYG{p}{,}\PYG{p}{)}
\PYG{n}{output\PYGZus{}slots} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Totem}\PYG{o}{.}\PYG{n}{VarSwapVolBasisProxy}\PYG{p}{,}\PYG{p}{)}
\PYG{n}{producer\PYGZus{}key} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{product\PYGZus{}type\textbar{}region}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}


\chapter{MRP DB}
\label{\detokenize{mrb:mrp-db}}\label{\detokenize{mrb::doc}}
The MRP database is needed in order to:
\begin{itemize}
\item {} 
Synchronize the access to the data from different processes running of different machines

\item {} 
Persist the slot’s states

\item {} 
Keep track of slot’s dependency trees

\item {} 
Keep track of running producers

\item {} 
Joining the slot’s data to be feed to the producers

\end{itemize}

In the following, the required table are listed


\section{underlyings}
\label{\detokenize{mrb:underlyings}}\begin{itemize}
\item {} 
uid

\item {} 
uname

\item {} 
ric

\item {} 
currency

\item {} 
class

\item {} 
type

\item {} 
region

\end{itemize}


\section{slot\_classes}
\label{\detokenize{mrb:slot-classes}}
Information of the slot, with columns:
\begin{itemize}
\item {} \begin{description}
\item[{SLOT\_NAME}] \leavevmode
Name of the slot, for example MarketData.Vanilla.Totem

\end{description}

\item {} \begin{description}
\item[{SLOT\_ID}] \leavevmode
Identifier

\end{description}

\item {} \begin{description}
\item[{KEY\_MAP}] \leavevmode
This is a string made up of the slot’s keys joined by ‘/, for example ‘uname/region/type’

\end{description}

\end{itemize}


\section{producer\_classes}
\label{\detokenize{mrb:producer-classes}}
Information on the producer.


\section{SLOT\_DEPS}
\label{\detokenize{mrb:slot-deps}}
Information on slots’ dependencies:
\begin{itemize}
\item {} \begin{description}
\item[{SLOT\_ID}] \leavevmode
the id of the slot

\end{description}

\item {} \begin{description}
\item[{DEP\_ON\_ID}] \leavevmode
The slot SLOT\_ID depends on

\end{description}

\item {} \begin{description}
\item[{REQUIRED}] \leavevmode
The dependency is REQUIRED (1) or OPTIONAL (0)

\end{description}

\end{itemize}


\section{SLOT\_TABLE}
\label{\detokenize{mrb:slot-table}}
Keeps track of existing slots and register them with the SID.
Columns are:
\begin{itemize}
\item {} \begin{description}
\item[{SLOT\_ID}] \leavevmode
id of the slot, a foreign key into SLOT\_META

\end{description}

\item {} \begin{description}
\item[{DATE}] \leavevmode
The valuation date

\end{description}

\item {} \begin{description}
\item[{SLOT\_KEY}] \leavevmode
This is a string made up of the slot’s keys joined by ‘/, for
example ‘0123456/EURO/INDEX’. The semantic is provided by they
SLOT\_META.KEY\_MAP

\end{description}

\item {} \begin{description}
\item[{SID}] \leavevmode
unique identifier

\end{description}

\item {} \begin{description}
\item[{SSTATUS}] \leavevmode
slot’s status

\end{description}

\item {} \begin{description}
\item[{FILE}] \leavevmode
path to the file containing the data

\end{description}

\end{itemize}


\section{SLOT\_TREE}
\label{\detokenize{mrb:slot-tree}}
Slot’s dependency tree. This is required to invalidate downstream slots
(state set to ‘stale’) upon slot’s update.
\begin{itemize}
\item {} \begin{description}
\item[{SID1}] \leavevmode
SID of the slot

\end{description}

\item {} \begin{description}
\item[{SID2}] \leavevmode
SID of a slot depending on SID1

\end{description}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
This table is not a duplicate of SLOT\_DEPS. The latter describes they
dependencies between slots through methodologies, the former
the actual dependency on the produced slots
\end{sphinxadmonition}


\section{RUNNING\_PROD}
\label{\detokenize{mrb:running-prod}}
The table of the running producers
\begin{itemize}
\item {} \begin{description}
\item[{PROD\_NAME}] \leavevmode
The producer name

\end{description}

\item {} \begin{description}
\item[{PID}] \leavevmode
The producer unique id

\end{description}

\item {} \begin{description}
\item[{START\_TIME}] \leavevmode
The time when the producer was kicked off

\end{description}

\item {} \begin{description}
\item[{SID}] \leavevmode
The slots being produced

\end{description}

\end{itemize}


\section{SLOTs Tables}
\label{\detokenize{mrb:slots-tables}}
Each slot is associated with a table with same name as the slot, with ‘.’ replaced by ‘\_’.
The tables have columns which are specific to the relative slot, apart a few which are fixed:
\begin{itemize}
\item {} \begin{description}
\item[{DATE}] \leavevmode
The valuation date

\end{description}

\item {} \begin{description}
\item[{SID}] \leavevmode
The id from the SLOTS\_TABLE

\end{description}

\item {} \begin{description}
\item[{LAST\_UPDATED}] \leavevmode
The last update time

\end{description}

\item {} \begin{description}
\item[{PRODUCER}] \leavevmode
The producer that created the data

\end{description}

\item {} \begin{description}
\item[{PRIORITY}] \leavevmode
The producer’s priority

\end{description}

\item {} 
Set of specific keys that identifies the item itself. In SQL parlance, these are \sphinxstyleemphasis{primary keys}.

\end{itemize}

PRODUCERs Tables
Each producers is associated with a list of slots which where notified to the producers and accepted.
\begin{itemize}
\item {} \begin{description}
\item[{SID}] \leavevmode
the id from the slot\_table

\end{description}

\item {} \begin{description}
\item[{PSTATUS}] \leavevmode
status of the processing (‘pending’,’processing’)

\end{description}

\end{itemize}


\section{parcels\_table}
\label{\detokenize{mrb:parcels-table}}
Contains the Information that the producer proxy need to bundle the slots into
parcels and kick-off tasks.

So far we have:
\begin{itemize}
\item {} \begin{description}
\item[{pid}] \leavevmode
The producer id

\end{description}

\item {} \begin{description}
\item[{sid}] \leavevmode
The slot id acknowledged by the producer

\end{description}

\item {} \begin{description}
\item[{uname, currency, class, type, region}] \leavevmode
key from the slot, some could be None

\end{description}

\end{itemize}


\chapter{The slot pseudo code description}
\label{\detokenize{slots:the-slot-pseudo-code-description}}\label{\detokenize{slots::doc}}

\section{The monitor pseudo code}
\label{\detokenize{slots:the-monitor-pseudo-code}}
The monitor is that piece of code that monitor the \sphinxstyleemphasis{buffer} folder. In this folder, producers
drops items and the monitor processes that items and plug them into the slots.
::
Upon arrival of new items, the slot table will be updated setting the new status as either ‘updated’ or
‘failed’. It is not in the mandate of the Monitor to perform further processing, which is left for the SlotTable.flush()
method.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} MAX\PYGZus{}PROCESSED\PYGZus{}ITEMS is the maximum number of incoming items that}
\PYG{c+c1}{\PYGZsh{} can be processed by this machine\PYGZsq{}s instance}
\PYG{n}{MAX\PYGZus{}PROCESSED\PYGZus{}ITEMS} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{c+c1}{\PYGZsh{} This piece of code monitor for incomining files in the}
\PYG{c+c1}{\PYGZsh{} buffer folder}
\PYG{k}{def} \PYG{n+nf}{process}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{processed\PYGZus{}items}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{k}{with} \PYG{n}{buffer\PYGZus{}lock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} wait until it gains access to the directory}
                \PYG{k}{with} \PYG{n}{mrp\PYGZus{}lock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*.json}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n+nb}{id} \PYG{o}{=} \PYG{n}{build\PYGZus{}id\PYGZus{}from}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
                                \PYG{n}{fname} \PYG{o}{=} \PYG{n}{build\PYGZus{}file\PYGZus{}name}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
                                \PYG{k}{if} \PYG{n}{f}\PYG{o}{.}\PYG{n}{status} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ok:}
                                        \PYG{n}{SlotTable}\PYG{o}{.}\PYG{n}{updated}\PYG{p}{(}\PYG{n+nb}{id}\PYG{p}{,} \PYG{n}{fname}\PYG{p}{)}
                                \PYG{k}{else}\PYG{p}{:}
                                        \PYG{n}{SlotTable}\PYG{o}{.}\PYG{n}{failed}\PYG{p}{(}\PYG{n+nb}{id}\PYG{p}{)}
                                \PYG{n}{move\PYGZus{}file\PYGZus{}from\PYGZus{}to}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{fname}\PYG{p}{)}
                                \PYG{n}{processed\PYGZus{}items} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
                                \PYG{k}{if} \PYG{n}{processed\PYGZus{}items} \PYG{o}{==} \PYG{n}{MAX\PYGZus{}PROCESSED\PYGZus{}ITEMS}\PYG{p}{:}
                                        \PYG{k}{break}
\end{sphinxVerbatim}


\section{The slots pseudo code}
\label{\detokenize{slots:the-slots-pseudo-code}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This piece of code manages the update of the slots status}
\PYG{c+c1}{\PYGZsh{} It is responsible to}
\PYG{c+c1}{\PYGZsh{} 1. create new slots}
\PYG{c+c1}{\PYGZsh{} 2. set the status to \PYGZsq{}pending\PYGZsq{} or to \PYGZsq{}invalid\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} 3. It should also the the status to \PYGZsq{}pending\PYGZsq{} and \PYGZsq{}current\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} The status \PYGZsq{}updated\PYGZsq{} is necessary as it is not obvious that there are}
\PYG{c+c1}{\PYGZsh{} spare producers able to accept the work.}
\PYG{c+c1}{\PYGZsh{} The \PYGZsq{}failed\PYGZsq{} state is needed too \PYGZhy{} only once all dependent slots have}
\PYG{c+c1}{\PYGZsh{} been invalidated the state can go to \PYGZsq{}invalid\PYGZsq{}}
\PYG{n}{SSTATUS} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{updated}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{current}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{stale}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pending}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{invalid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{class} \PYG{n+nc}{SlotTable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        This is the SLOT\PYGZus{}TABLE.}
\PYG{l+s+sd}{        It has 3 public member functions:}
\PYG{l+s+sd}{        set\PYGZus{}to\PYGZus{}updated(s,fname) : set the status to \PYGZsq{}updated\PYGZsq{}}
\PYG{l+s+sd}{        set\PYGZus{}to\PYGZus{}failed(s) : set the status to \PYGZsq{}failed\PYGZsq{}}
\PYG{l+s+sd}{        flush() : process all the changes}
\PYG{l+s+sd}{        get\PYGZus{}slot\PYGZus{}id(s) : produce a unique slot it}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{sid} \PYG{o}{=} \PYG{n+nb+bp}{None}
        \PYG{n}{key} \PYG{o}{=} \PYG{n+nb+bp}{None} \PYG{c+c1}{\PYGZsh{} concatenation of keys}
        \PYG{n}{slotname} \PYG{o}{=} \PYG{n+nb+bp}{None}
        \PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb+bp}{None} \PYG{c+c1}{\PYGZsh{} path to the file containing the data}
        \PYG{n}{sstatus} \PYG{o}{=} \PYG{n+nb+bp}{None} \PYG{c+c1}{\PYGZsh{} this is the slot status in SSTATUS}
        \PYG{n}{updatetime} \PYG{o}{=} \PYG{n+nb+bp}{None} \PYG{c+c1}{\PYGZsh{} the time stamp of last update}

        \PYG{k}{def} \PYG{n+nf}{\PYGZus{}slot\PYGZus{}to\PYGZus{}id}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
                \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{                concatenate all the slot s attributes, joining by \PYGZsq{}.\PYGZsq{}}
\PYG{l+s+sd}{                \PYGZsq{}\PYGZsq{}\PYGZsq{}}
                \PYG{n}{res} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{name} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{s}\PYG{o}{.}\PYG{n}{date}\PYG{p}{)}
                \PYG{n}{values} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{s}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{values}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{s}\PYG{o}{.}\PYG{n}{k}\PYG{p}{)}
                \PYG{k}{return} \PYG{n}{res} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{valued}\PYG{p}{)}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

        \PYG{k}{def} \PYG{n+nf}{\PYGZus{}slot\PYGZus{}exist}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
                \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{                Return True is s is in the table, False otherwise}
\PYG{l+s+sd}{                \PYGZsq{}\PYGZsq{}\PYGZsq{}}
                \PYG{n+nb}{id} \PYG{o}{=} \PYG{n}{\PYGZus{}slot\PYGZus{}to\PYGZus{}id}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
                \PYG{n}{sid} \PYG{o}{=} \PYG{n}{select}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{sid} \PYG{o}{==} \PYG{n+nb}{id}\PYG{p}{)}
                \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sid}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                        \PYG{k}{return} \PYG{n+nb+bp}{True}
                \PYG{k}{return} \PYG{n+nb+bp}{False}

        \PYG{k}{def} \PYG{n+nf}{\PYGZus{}add\PYGZus{}slot}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
                \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{                Insert the slot s in the table with status=\PYGZsq{}void\PYGZsq{} as return the sid}
\PYG{l+s+sd}{                \PYGZsq{}\PYGZsq{}\PYGZsq{}}
                \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}slot\PYGZus{}exist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{raise} \PYG{n+ne}{Exception}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Slot already exist}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
                \PYG{n+nb}{id} \PYG{o}{=} \PYG{n}{create\PYGZus{}id}\PYG{p}{(}\PYG{p}{)}
                \PYG{n}{SlotTable}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{date}\PYG{o}{=}\PYG{n}{s}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{slotname}\PYG{o}{=}\PYG{n}{s}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{sstatus}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{void}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sid}\PYG{o}{=}\PYG{n+nb}{id}\PYG{p}{)}
                \PYG{k}{return} \PYG{n+nb}{id}

        \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}slot\PYGZus{}id}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
                \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{                concatenate all the slot s attributes, joining by \PYGZsq{}.\PYGZsq{}}
\PYG{l+s+sd}{                check if the sid is already available}
\PYG{l+s+sd}{                if it is, return it otherwise create a new one,}
\PYG{l+s+sd}{                insert into the table and return it}
\PYG{l+s+sd}{                TODO: how do we treat date? Should be a part of the key}
\PYG{l+s+sd}{                \PYGZsq{}\PYGZsq{}\PYGZsq{}}
                \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}slot\PYGZus{}exist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{return} \PYG{n}{SlotTable}\PYG{o}{.}\PYG{n}{select}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{sid} \PYG{o}{==} \PYG{n+nb}{id}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fetch\PYGZus{}one}\PYG{p}{(}\PYG{p}{)}
                \PYG{k}{raise} \PYG{n+ne}{Exception}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Slot not existing}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{k}{def} \PYG{n+nf}{\PYGZus{}update}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
                \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{                The item was updated.}
\PYG{l+s+sd}{                All listeners are notified and then the item\PYGZsq{}s status is set to \PYGZsq{}pending\PYGZsq{}.}
\PYG{l+s+sd}{                The status of dependent slots are set to \PYGZsq{}stale\PYGZsq{}}
\PYG{l+s+sd}{                NB: The slot id always exists as it is created once the producer accepts the incoming slots}
\PYG{l+s+sd}{                and update the SlotTree table}
\PYG{l+s+sd}{                \PYGZsq{}\PYGZsq{}\PYGZsq{}}
                \PYG{n}{sid} \PYG{o}{=} \PYG{n}{get\PYGZus{}slot\PYGZus{}id}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
                \PYG{n}{listeners} \PYG{o}{=} \PYG{n}{get\PYGZus{}listeners\PYGZus{}of}\PYG{p}{(}\PYG{n}{s}\PYG{o}{.}\PYG{n}{name}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{listeners}\PYG{p}{:}
                        \PYG{n}{l}\PYG{o}{.}\PYG{n}{accept}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
                \PYG{n}{set\PYGZus{}to\PYGZus{}pending}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}

        \PYG{k}{def} \PYG{n+nf}{\PYGZus{}invalidate\PYGZus{}dependents}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{sid}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{invalid\PYGZus{}sids} \PYG{o}{=} \PYG{n}{SlotTree}\PYG{o}{.}\PYG{n}{select}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sid2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{SID1}\PYG{o}{=}\PYG{n}{sid}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{sid} \PYG{o+ow}{in} \PYG{n}{invalid\PYGZus{}sids}\PYG{p}{:}
                        \PYG{n}{set\PYGZus{}to\PYGZus{}stale}\PYG{p}{(}\PYG{n}{sid}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{get\PYGZus{}listener}\PYG{p}{(}\PYG{n}{sid}\PYG{o}{.}\PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{l}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{sid}\PYG{p}{)}
                        \PYG{n}{\PYGZus{}invalidate\PYGZus{}dependents}\PYG{p}{(}\PYG{n}{sid}\PYG{p}{)}

        \PYG{k}{def} \PYG{n+nf}{\PYGZus{}failed}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}
                \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{                The item processing failed.}
\PYG{l+s+sd}{                The status of dependent slots are set to \PYGZsq{}stale\PYGZsq{}}
\PYG{l+s+sd}{                \PYGZsq{}\PYGZsq{}\PYGZsq{}}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{set\PYGZus{}to\PYGZus{}failed}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
                \PYG{n}{s}\PYG{o}{.}\PYG{n}{file} \PYG{o}{=} \PYG{n+nb+bp}{None}
                \PYG{n}{sid} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}get\PYGZus{}slot\PYGZus{}id}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
                \PYG{n}{\PYGZus{}invalidate\PYGZus{}dependents}\PYG{p}{(}\PYG{n}{sid}\PYG{p}{)}

        \PYG{k}{def} \PYG{n+nf}{set\PYGZus{}to\PYGZus{}updated}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{fname}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{sid} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}get\PYGZus{}slot\PYGZus{}id}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{sid}\PYG{o}{==}\PYG{n}{sid}\PYG{p}{)}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{(}\PYG{n}{status}\PYG{p}{,}\PYG{n+nb}{file}\PYG{p}{)}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{updated}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{fname}\PYG{p}{)}\PYG{p}{)}

        \PYG{k}{def} \PYG{n+nf}{set\PYGZus{}to\PYGZus{}failed}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{sid} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}get\PYGZus{}slot\PYGZus{}id}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{sid}\PYG{o}{==}\PYG{n}{sid}\PYG{p}{)}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{(}\PYG{n}{status}\PYG{p}{,}\PYG{n+nb}{file}\PYG{p}{)}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{updated}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{fname}\PYG{p}{)}\PYG{p}{)}

        \PYG{k}{def} \PYG{n+nf}{flush}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{for} \PYG{n}{u} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{select}\PYG{p}{(}\PYG{n}{sid}\PYG{p}{)}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{status}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{updated}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}update}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{select}\PYG{p}{(}\PYG{n}{sid}\PYG{p}{)}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{status}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{updated}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}failed}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\end{sphinxVerbatim}


\section{The ProxyProducer pseudo code}
\label{\detokenize{slots:the-proxyproducer-pseudo-code}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{ProxyProducer}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{producer}\PYG{p}{)}\PYG{p}{:}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{producer\PYGZus{}name} \PYG{o}{=} \PYG{n}{producer}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{required\PYGZus{}slot\PYGZus{}num} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{producer}\PYG{o}{.}\PYG{n}{required\PYGZus{}slots}\PYG{p}{)}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{optional\PYGZus{}slot\PYGZus{}num} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{producer}\PYG{o}{.}\PYG{n}{optional\PYGZus{}slots}\PYG{p}{)}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{keys} \PYG{o}{=} \PYG{n}{producers}\PYG{o}{.}\PYG{n}{keys}

        \PYG{k}{def} \PYG{n+nf}{accepted}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{sid}\PYG{p}{)}\PYG{p}{:}
                \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{                Return True if the sid is already registered in the table}
\PYG{l+s+sd}{                \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def} \PYG{n+nf}{accept}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{slot}\PYG{p}{)}\PYG{p}{:}
                \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{                Take the incoming slot, join it with the producer keys and insert it in the}
\PYG{l+s+sd}{                producer table}
\PYG{l+s+sd}{                \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{def} \PYG{n+nf}{launch}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
                \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{                1. take all distinct combination of producers keys}
\PYG{l+s+s2}{                2. for each combination compute the number n of required slots}
\PYG{l+s+s2}{                3. if n\PYGZgt{}self.required\PYGZus{}slot\PYGZus{}num and at east one row is not pending then}
\PYG{l+s+s2}{                        1. set all row to processing}
\PYG{l+s+s2}{                        2. kick\PYGZhy{}off the producer task}
\end{sphinxVerbatim}


\section{The SlotTree pseudo code}
\label{\detokenize{slots:the-slottree-pseudo-code}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{SlotTree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{SD1} \PYG{o}{=} \PYG{n+nb+bp}{None}
        \PYG{n}{SD2} \PYG{o}{=} \PYG{n+nb+bp}{None}
        \PYG{k}{def} \PYG{n+nf}{add}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{sd1}\PYG{p}{,} \PYG{n}{sd2}\PYG{p}{)}\PYG{p}{:}
                \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{                add the entry (sd1,sd2) to the table}
\PYG{l+s+sd}{                \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\end{sphinxVerbatim}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}